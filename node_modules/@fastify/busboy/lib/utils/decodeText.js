'use strict'

<<<<<<< HEAD
// Node has always utf-8
const utf8Decoder = new TextDecoder('utf-8')
const textDecoders = new Map([
  ['utf-8', utf8Decoder],
  ['utf8', utf8Decoder]
])

function getDecoder (charset) {
  let lc
  while (true) {
    switch (charset) {
      case 'utf-8':
      case 'utf8':
        return decoders.utf8
      case 'latin1':
      case 'ascii': // TODO: Make these a separate, strict decoder?
      case 'us-ascii':
      case 'iso-8859-1':
      case 'iso8859-1':
      case 'iso88591':
      case 'iso_8859-1':
      case 'windows-1252':
      case 'iso_8859-1:1987':
      case 'cp1252':
      case 'x-cp1252':
        return decoders.latin1
      case 'utf16le':
      case 'utf-16le':
      case 'ucs2':
      case 'ucs-2':
        return decoders.utf16le
      case 'base64':
        return decoders.base64
      default:
        if (lc === undefined) {
          lc = true
          charset = charset.toLowerCase()
          continue
        }
        return decoders.other.bind(charset)
    }
  }
}

const decoders = {
  utf8: (data, sourceEncoding) => {
    if (data.length === 0) {
      return ''
    }
    if (typeof data === 'string') {
      data = Buffer.from(data, sourceEncoding)
    }
    return data.utf8Slice(0, data.length)
  },

  latin1: (data, sourceEncoding) => {
    if (data.length === 0) {
      return ''
    }
    if (typeof data === 'string') {
      return data
    }
    return data.latin1Slice(0, data.length)
  },

  utf16le: (data, sourceEncoding) => {
    if (data.length === 0) {
      return ''
    }
    if (typeof data === 'string') {
      data = Buffer.from(data, sourceEncoding)
    }
    return data.ucs2Slice(0, data.length)
  },

  base64: (data, sourceEncoding) => {
    if (data.length === 0) {
      return ''
    }
    if (typeof data === 'string') {
      data = Buffer.from(data, sourceEncoding)
    }
    return data.base64Slice(0, data.length)
  },

  other: (data, sourceEncoding) => {
    if (data.length === 0) {
      return ''
    }
    if (typeof data === 'string') {
      data = Buffer.from(data, sourceEncoding)
    }

    if (textDecoders.has(this.toString())) {
      try {
        return textDecoders.get(this).decode(data)
      } catch {}
    }
    return typeof data === 'string'
      ? data
      : data.toString()
  }
=======
const decoder = new TextDecoder('utf-8')
const textDecoders = new Map([['utf-8', decoder]])

const decoders = new Map([
  ['utf-8', (data) => decoder.decode(data)],
  ['latin1', (data) => data.toString('latin1')],
  ['ascii', (data) => data.toString('ascii')],
  ['us-ascii', (data) => data.toString('ascii')],
  ['iso-8859-1', (data) => data.toString('latin1')],
  ['iso8859-1', (data) => data.toString('latin1')],
  ['iso88591', (data) => data.toString('latin1')],
  ['iso_8859-1', (data) => data.toString('latin1')],
  ['windows-1252', (data) => data.toString('windows-1252')],
  ['iso_8859-1:1987', (data) => data.toString('latin1')],
  ['cp1252', (data) => data.toString('cp1252')],
  ['x-cp1252', (data) => data.toString('cp1252')],
  ['utf16le', (data) => decoder.decode(new Uint16Array(data))],
  ['utf-16le', (data) => decoder.decode(new Uint16Array(data))],
  ['ucs2', (data) => decoder.decode(new Uint16Array(data))],
  ['ucs-2', (data) => decoder.decode(new Uint16Array(data))],
  ['base64', (data) => decoder.decode(Buffer.from(data, 'base64'))]
])

function getDecoder (charset) {
  return decoders.get(charset) || decoders.get('utf-8')
>>>>>>> 92dec27fdf3ebcb1f8ae0a00c18d5f3e95d36a79
}

function decodeText (text, sourceEncoding, destEncoding) {
  if (text) {
<<<<<<< HEAD
    return getDecoder(destEncoding)(text, sourceEncoding)
=======
    const decoder = getDecoder(destEncoding)
    if (typeof text === 'string') {
      return decoder(Buffer.from(text, sourceEncoding))
    }
    return decoder(text)
>>>>>>> 92dec27fdf3ebcb1f8ae0a00c18d5f3e95d36a79
  }
  return text
}

module.exports = decodeText
